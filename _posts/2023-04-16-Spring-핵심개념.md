---
title: "Spring - 핵심개념(POJO, IoC, AOP, PSA)"
categories: Spring
tags:
  - IoC
  - AOP
  - PSA
---  

**Spring(이하 스프링)은 Java로 웹 어플리케이션을 편하게 개발할 수 있도록 도와주는 오픈소스 프레임워크다.** 스프링은 이전 기술들과 비교해 웹 개발을 보다 간편하게 할 수 있어 개발 생산성을 높여준다. 이전 개발자가 작성해야했던 불필요하고 복잡한 코드들을 제거하여 비즈니스 로직에 집중할 수 있도록 도와준다. 스프링 프레임워크의 장점을 정리하자면 다음과 같다.

- **규칙성** : 프레임워크가 제시하는 직관적인 규칙만으로 필요한 기능을 구현할 수 있음
- **경량성** : 개발자들이 필요한 모듈만을 사용할 수 있도록 모듈화되어 있음
- **확장성** : 수 많은 모듈들을 지원하며, 사용중이던 모듈을 별도로 분리하기도 편리
- **넓은 생태계** : 오랜 역사로 지속적인 발전을 해오며 안정적인 개발과 개선이 보장됨. 수 많은 커뮤니티가 존재하고 레퍼런스가 많음
- IoC/DI, AOP, PSA 등의 기능들을 제공하여 유지/보수에 탁월

## POJO 지향

스프링으로 개발할 때의 강점은 POJO(Plain Old Java Object) 프로그래밍 지향과 이를 지원하는 확장기술들에서 나온다. POJO는 순수한 자바 객체를 의미하며, 이러한 **순수 자바만을 사용하는 것을 POJO 지향 프로그래밍**이라고 한다. POJO를 지향한다는 것은 **자바의 객체지향을 활용한 개발을 한다는 것**을 의미한다.

다른 서버사이드 프레임워크를 사용해 본 사람들은 ‘자바 어플리케이션에서 순수 자바와 객체지향을 사용하는건 당연한 거 아닌가?’라는 의문이 들 수도 있다. 스프링에서 POJO를 강조하는데에는 이유가 있다. 스프링 이전 웹 개발을 위해 사용한 EJB(Enterprise JavaBeans)에서는 비즈니스 로직을 처리하기 위해 EJB에 종속된 여러가지 인터페이스를 구현하고 클래스를 상속시켜야했다. 때문에 자바 본연의 객체 지향의 효과를 발휘하지 못했다. 이러한 문제점과 더불어 느린 성능, 낮은 개발 생산성 등으로 EJB는 몰락했고, **객체지향적인 설계의 장점을 살리며, 외부 기술이나 규약의 변화에 얽매이지 않는 자바 객체인 POJO**{: .font-highlight}와 그러한 POJO기반 개발을 지향하는 스프링이 각광받게 되었다.


💡 **POJO의 진정한 가치**  
POJO의 진정한 가치는 객체지향의 기본 원칙을 따르면서 확장성과 유지보수성이 뛰어난 코드를 작성할 수 있다는 것이다. POJO는 특정 프레임워크나 라이브러리에 종속되지 않기 때문에 어떤 환경에서도 **재사용이 가능**하다. 또한, 의존성이 없고 단순하고 간결하여 **테스트 코드 작성에도 용이**하다.  
{: .notice--info}

뿐만 아니라 스프링은 **개발자들의 POJO 지향 개발을 지원하기 위해** **IoC/DI, AOP, PSA와 같은 확장기능을 제공한다.**(즉, 객제지향의 장점을 살리고 확정성 및 유지보수성을 지원하기위한 기능을 제공한다는 뜻)

![POJO 지원 핵심개념](https://user-images.githubusercontent.com/52196792/231714313-4678b006-a16b-4846-89e5-4d629cb5d1b2.png){: .align-center style="width: 50%;"}  
POJO를 지원하는 기능들
{: .image-caption style="font-size: 14px;"}  

<br />  

## IoC/DI

개잘자들이 순수 자바만으로 어플리케이션을 설계할 수 있도록 지원하는 스프링의 핵심기술 중 하나는 IoC/DI이다. IoC/DI를 설명하기 전, 이전에 어떠한 문제점들이 존재하였기에 IoC/DI의 중요성이 강조되고 있는지에 대해 알아보자. 일반적으로 각 객체는 자신이 사용할 객체를 내부에서 생성하고 관리할 수 있다. 하지만 여기에는 치명적인 단점이 존재하는데 바로, **변경에 취약하다는 것**이다.  

예를 들어, 개발자 객체가 존재한다고 가정하자. 이 개발자 객체는 내부에서 윈도우노트북 객체를 생성하고 윈도우노트북 객체가 가진 메서드들을 십분 활용할 것이다. 시간이 흐르고 윈도우노트북 객체를 맥북 객체로 바꿀 때가 되었다. 우리는 개발자 객체 내부의 윈도우노트북 객체의 생성부터 활용되는 모든 부분을 맥북 객체로 바꾸어야한다. 긴 시간이 걸릴 것이다. 하지만 이 정도면 괜찮지! 라는 생각을 할 수도 있다. 만약 개발자 객체뿐만 아니라 기획자 객체, 마케터 객체 등등 수 많은 객체들 또한 윈도우노트북 객체를 사용하고 있었더라면? 상상만으로 끔찍하다.  

<br />  

![IoC 적용 전](https://user-images.githubusercontent.com/52196792/232281568-9c98ed4e-7c7b-4e8a-9bc8-6e81578588fd.png){: .align-center style="width: 60%;"}  
각 객체들이 의존객체를 스스로 생성하는 모습
{: .image-caption style="font-size: 14px;"}  


그렇다면 이러한 변경에도 유연하게 대처할 수 있는 방법이 있을까? 정답은 **객체지향 설계가 역설하는 역할과 책임의 분리**{: .font-highlight}에 있다. 그리고 그 중심에 IoC가 존재한다.  

<br />  

### IoC(제어의 역전)

IoC(Inversion Of Control, 제어의 역전)란, **제어의 흐름을 직접 제어하는게 아닌 외부에서 관리하는 것**이다. 조금 더 쉽게 풀자면 **내가 제어할 부분을 다른 객체에게 넘기는 것**{: .font-highlight}을 말한다.

‘내가 제어할 부분’이란 말이 모호하게 들린다. 어떤 부분을 이야기하는 걸까? 내부에서 참조하는 객체의 생성과 그 객체의 관리를 일컫는다. 즉, **참조하는 객체(의존성)의 생성과 관리에 대한 책임을 내부에서 분리하는 것**{: .font-highlight}이다. 위 개발자 객체의 예를 보자면, 윈도우노트북 생성과 관리를 다른 객체가 수행한다는 것이다. 개발자 객체는 생성된 객체를 받아 사용하기만 할 뿐이다. 개발자 객체는 본인의 역할만 수행하고 참조객체에 대한 생성의 책임을 외부객체에게 맡긴다. 이렇게 책임을 위임함으로써 **객체간의 의존도를 줄일 수 있다.**  

<br />  

![외부에서 객체를 생성하는 모습](https://user-images.githubusercontent.com/52196792/232283555-b08c629a-2f00-432c-ab46-03982466ca73.png){: .align-center style="width: 50%;"}  
외부에서 의존 객체를 생성하는 모습
{: .image-caption style="font-size: 14px;"}  

하지만 여전히 윈도우노트북 객체만을 가질 수 있는 모습을 볼 수 있다. 이래서야 변경에 유연하다고 이야기 할 수 없다. 여기서 IoC와 뗄래야 뗄 수 없는 원칙인 DIP의 개념이 나온다.

DIP(Dependency Inversion Principle, 의존성 역전 원칙)은 그 유명한 SOLID 원칙 중 하나이다.(DI, Dependency Injection과 의미가 다름을 주의하자) DIP는 **객체의 의존이 구현체에 의존하는 것이 아닌 추상화에 의존하라는 원칙**이다.

앞선 개발자 객체 예시를 다시보자. 개발자 객체는 윈도우노트북 객체에 의존되어 있다. 다시 말해, 윈도우노트북 객체라는 구현체에 의존하고 있다는 의미이다. 즉, DIP 원칙을 준수하고 있지 않다. 그렇다면 어떻게 바뀌어야할까?  

<br />  

![노트북 추상체에 의존하는 모습](https://user-images.githubusercontent.com/52196792/232286486-65ec2aa7-1946-4ef0-bfa2-f556f48a655a.png){: .align-center style="width: 50%;"}  
interface에 의존하는 모습
{: .image-caption style="font-size: 14px;"}  

위 그림과 같이 노트북이라는 추상화에 의존하면 된다. 해당 interface에 의존하게 된다면 interface를 구현하는 모든 객체로 교체될 수 있기 때문이다. 개발자는 interface의 명세대로만 활용하니 의존객체가 바뀌어도 내부에서 수정할 일은 전혀 없어진다.

이처럼 IoC는 DIP와 밀접하게 연관되어 있다. IoC 또한 SOLID 원칙에 포함되어 있지는 않지만 **의존 객체의 생성과 관리에 대한 책임을 분리**하는 원칙이다. 따라서 이러한 원칙을 준수하기 위해 구현방법이 존재하며, 대표적으로 Factory패턴과 DI가 존재한다.

💡 **Factory패턴보단 DI**  
Facotory 패턴은 객체 생성을 캡슐화하여 생성에 대한 결정권을 팩토리 클래스가 가지는 방법이다. 외부에서 객체생성을 요구하면 받은 인자로 객체를 생성하여 반환하는 방식이다. 하지만 DI에 비해 코드가 복잡하며, 구현 방식에 따라 **런타임에 객체를 생성함으로써 오버헤드가 발생**할 수 있다. 뿐만아니라 **따로 요청을 해야한다는 부분에서 주입하는 방식에 비해 의존도가 생긴다는 단점**이 있다.  
{: .notice--info}  

<br />  

### DI(Dependency Injection, 의존성 주입)

DI(Dependency Injection)은 IoC를 구현한 방법으로 하나의 디자인 패턴이다. **객체의 생성과 관리의 책임을 가지고,** **생성한 객체를 참조하는 객체에게 주입해주는 것이 핵심**{: .font-highlight}이다.  

그렇다면, 외부에서 생성한 객체를 어떻게 객체에게 주입할까? 현대의 객체 지향 설계에 큰 영향력을 미친 개발자, 마틴 파울러는 다음과 같은 객체 주입 방법 3가지를 제시하였다.

- **생성자 주입**  
필요한 의존성을 모두 포함하는 클래스 생성자를 만들고 그 생성자를 통해 주입
- **setter 주입**  
의존성을 입력받는 setter 메서드를 만들고 이를 통해 주입
- **인터페이스 주입**  
의존성을 주입하는 함수를 인턴페이스에 정의하고 이 인턴페이스를 구현, 이를 통해 의존성 주입

생성자를 통해 주입한다면, 불변성을 보장하는 장점을 그리고 setter 및 인터페이스를 통해 주입한다면 불변성을 보장할 순 없지만 선택적 주입이 가능하다는 장점이 존재한다.  

<br />  

**DIP(추상화 의존) + DI로 얻는 장점**  
- **테스트 코드 작성에 용이**{: .font-highlight}  
만약 객체 내부에서 의존 객체 생성의 책임을 진다면 테스트 작성시 내부 객체를 제어가 불가능하다(가짜 객체 사용 등), 하지만 추상화 의존 + 외부주입을 통해 테스트시 이용할 객체로 교체하여 테스트할 수 있어 안정성과 효율성을 높일 수 있다.
- **변경에 용이**{: .font-highlight}  
손쉽게 객체를 교체할 수 있다는 것은 곧 변경에 용이하다는 말이다. interface 명세만 지킨다면 주입객체가 무엇이 되든 객체 내부가 수정될 이유가 전혀 없다.

정리하자면, **IoC는 의존 객체의 생성 및 관리를 외부에게 맡기는 원칙이며, DI는 IoC의 원칙에 따라 객체를 생성하고, 생성된 객체에 의존하는 객체에게 주입시켜 주는 과정이다. 이 과정에서 의존하는 객체는 구현체에 의존하지 않고 추상화에 의존하면서 보다 확장성 있고 유연한 어플리케이션을 만들 수 있다.**  

<br />  

### Spring의 IoC Container(DI Container)

**객체를 생성 및 관리하고 의존성을 주입해주는 역할을 담당하는 객체를** IoC Container 혹은 DI Container라고 부른다. 스프링은 이러한 **IoC Container를 내장하여 개발자로 하여금 적은 코드로 객체관리와 의존성 주입을 손쉽게 할 수 있도록 도와준다.**{: .font-highlight} 개발자는 생성과 의존성을 주입 받아야할 객체에 어노테이션을 붙임으로써 스프링 프레임워크에게 관리를 위임할 수 있다.  

<br />  

**IoC Container의 장점**  
- **객체 생성 및 의존성 주입 자동화**{: .font-highlight}  
개발자가 객체를 직접 생성하고 의존성을 주입하는 작업을 자동화하여 코드의 복잡도를 줄이고 개발생산성을 높일 수 있다.
- **객체 라이프사이클 관리 자동화**{: .font-highlight}  
객체 생성,초기화, 사용, 소멸까지 라이플사이클을 관리해줌으로써 개발자의 부담이 줄어들고 안정적인 애플리케이션을 만들 수 있다.
- **모듈화 및 유연성이 높음**{: .font-highlight}  
의존성을 주입하는 방식으로 모듈화된 코드 재사용, 새로운 기능 추가 등의 작업이 쉬워진다. 또한, 객체 생성과 의존성 주입을 외부 설정 파일로 관리할 수 있어 동작 변경 및 확장성이 있다
- **테스트의 용이성(DI의 장점과 동일)**{: .font-highlight}  
외부에서 주입함으로써 테스트 환경에서 다른 객체로 쉽게 교체할 수 있다. 테스트의 안정성과 효율성이 높다.

즉, IoC Container는 객체를 생성하고 관리하기 때문에 개발자는 POJO를 이용하여 간단하고 유연한 애플리케이션을 개발할 수 있다.