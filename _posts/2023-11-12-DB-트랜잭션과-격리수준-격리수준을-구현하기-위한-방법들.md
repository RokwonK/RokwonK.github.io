---  
title: "DB 트랜잭션과 격리수준, 격리수준을 구현하기 위한 방법들"
categories: CS
tags:
  - database
---  

데이터시스템에는 여러가지 문제가 생길 수 있다. 데이터베이스로의 쓰기 연산 실패, 데이터 조작 중 어플리케이션 다운, 애플리케이션과 데이터베이스 간 네트워크 통신 장애, 데이터베이스로의 동시 쓰기 등 여러가지 결함이 발생할 수 있다. 이러한 결함이 발생할 때면 데이터베이스 내 데이터들의 일관성은 무자비하게 박살난다.

신뢰성 있는 시스템을 구축하기 위해서는 이러한 결함을 처리해 시스템의 장애로 이어지는 것을 막아야 한다. **트랜잭션**은 이러한 문제들을 단순화하는 메커니즘이다. 몇 가지 작업(읽기, 쓰기 모두)을 하나의 논리적 단위로 묶어 모두 성공시키거나 모두 실패시키는 방법으로 부분 실패를 걱정할 필요가 없다.

다시말해, **트랜잭션은 안정성을 보장하는 역할**을 한다. 복잡한 **문제 풀이과정을 단순화한 덕분에 어플리케이션에서는 어느 정도 잠재적인 오류와 동시성 문제를 무시**할 수 있다.

실제로 어플리케이션에서 트랜잭션과 격리수준을 통해 데이터베이스에 쉽게 접근가능하지만 데이터베이스 내부적으로는 여러가지 문제점들이 발생한다. 때문에 데이터베이스는 트랜잭션 보장에 필요한 여러가지 알고리즘들을 사용한다.(어떤 알고리즘을 어떻게 사용하느냐에 따라 많은 트랜잭션이 수행되는 시스템에서의 성능과 가용성에 큰 영향을 미친다.)

이러한 트래잭션 보장을 위한 여러가지 방법들은 분산 시스템에서의 트랜잭션(분산 트랜잭션)에서도 비슷한 매커니즘으로 동작하지 않을까? 지금은 추측이지만 우선은 그 구현방법들에 대해 자세하게 파보도록 하자.


## 트랜잭션의 특징
트랜잭션이 제공하는 안정성 보장은 ACID로 잘 알려져 있다. 

원자성(Atomicity)은 **일련의 과정이 모두 성공하거나 모두 실패함을 보장**한다. 이를 통해 데이터의 일관성을 맞출 수 있다. 원자성이 없다면 실행 도중 생긴 문제를 어플리케이션 수준에서 롤백시키는 로직을 구현해야한다. 상상만해도 끔찍하다.

일관성(Consistency)는 **항상 진실이어야 하는 어떠한 선언(불변식)이 있으며 이 선언이 깨지지 않음을 보장**한다. 예를 들어, DDL 등에 정의한 데이터 제약조건이 올바르게 동작한다는 것을 보장한다. 하지만 대부분의 트랜잭션에서 다중 객체의 수정에 있어 일관성을 보장하기 위해서 어플리케이션 수준에서의 노력이 필요하다. 때문에 일관성은 ACID라는 약자를 맞추기 위해 끼어들었다는 소문이 있기도 하다.

격리성(Isolcation)은 **서로 다른 트랜잭션간 배타적으로 동작함을 보장**한다. 다시말해, 같은 리소스에 접근하여 생기는 동시성 문제가 발생하지 않는다. 때문에 격리성은 직렬성이라는 용어로 공식화되기도 한다. 하지만 격리성(직렬성)은 성능에 큰 영향을 미쳐 `완화된 격리수준`을 사용한다. 완화된 격리수준에서는 몇 가지 동시성 문제가 발생하는데 이는 이후에 이어 설명한다.

지속성(Durability)는 **한 번 저장된 데이터는 손실되지 않음을 보장**한다. 트랜잭션이 성공적으로 커밋되었다면 하드웨어 결함이 발생하거나 데이터베이스가 죽어도 데이터가 손실되지 않는다고 보장한다. 완벽한 지속성을 보장하려면 트랜잭션이 커밋되었다고 어플리케이션으로 보고하기 전 디스크로 쓰기를 하거나 DB 레플리케이션을 사용 중이라면 복제가 완료될 때까지 기다려야 한다.


## 완화된 격리 수준
서로 다른 트랜잭션이 동일한 데이터에 접근하지 않는다면 안전하게 병렬로 실행될 수 있다. 하지만 대부분의 경우 쓰기 작업 중 읽기 작업이 실행되거나 서로 다른 트랜잭션 같은 데이터로 쓰기 작업을 동시에 실행하는 문제가 발생한다. 따라서, 동시성 문제는 필연적이라 데이터베이스는 격리성을 제공하여 어플리케이션 개발자들에게 동시성 문제를 감추었다.

하지만 직렬성 격리(트랜잭션을 직렬로 실행하는 것과 같은 결과를 보장)는 성능 비용이 존재한다. 때문에 모든 이슈를 보호해주지는 못하지만 완화된 격리 수준을 사용한다. 이러한 완화된 격리 수준은 여러가지 동시성 문제를 일으킬 수 있다.

### 커밋 후 읽기
커밋 후 읽기(Committed Read)는 **트랜잭션 내 데이터를 읽을 때 커밋된 데이터만을 읽고 쓸 수 있다.** 이 격리 수준은 두 가지를 보장해준다.
1. `Dirty Read`
2. `Dirty Write`

A트랜잭션이 커밋되지 않은 데이터를 읽어 해당 데이터를 사용하고, 이후 해당 데이터가 롤백이 된다면 잘못된 데이터를 이용한 처리과정이 생기는 것이다. 이러한 문제를 Dirty Read라고 부른다. 커밋 후 읽기는 커밋된 데이터만을 읽어 이 문제를 해결해 준다.

A트랜잭션과 B트랜잭션이 같은 데이터를 동시에 수정한다고 가정하자. A트랜잭션이 데이터를 수정 후 커밋하기 전 B트랜잭션이 해당 데이터를 다시금 수정한다면 데이터가 불일치가 일어난다. A트랜잭션이 이후에 커밋을 완료하였어도 결과적으로 원하는 데이터로 수정되지 않았을 것이다.

예를 들어보자. Rokwon이 차를 사고자 한다. 차를 살때 데이터베이스에 두 번의 쓰기 필요하다.
1. 차량목록에서 해당 차량의 구매자를 바꾼다.
2. 해당 차량의 판매송장이 구매자로 전송되어야 한다. 따라서, 송장목록에서 해당 차량의 판매송장의 주인을 구매자로 바꾼다.

이때, 동시에 KIM도 같은 차량을 구매버리면 다음과 같이 서로 다른 쓰기가 겹쳐 일관성이 깨지는 상황이 발생할 수 있다.

![더티 쓰기](https://github.com/kids-ground/mentos-backend/assets/52196792/5364772d-80bc-47ef-b7e5-23dffc236027){: .align-center style="width: 70%;"}  
더티 쓰기
{: .image-caption style="font-size: 14px;" }  


더티 쓰기와 같은 문제는 많은 데이터베이스에서 로우 수준 잠금을 사용해 더티 쓰기를 방지한다. 쓰기를 하기 위해서 잠금을 획득해야하는 것이다. 그리고 커밋이 끝날때까지 해당 락을 보유해야 하며, 커밋 후 반환한다. 이런 **잠금은 해당 격리 수준 사용시 데이터베이스에 의해 자동으로 실행**된다. (Oracle, PostgreSQL 과 같은 많은 데이터베이스에서 커밋 후 읽기 격리수준을 기본 격리수준으로 사용하고 있다.)


### 스냅숏 격리
커밋 후 읽기 격리수준에서 Dirty Read와 Dirty Write 같은 동시성 문제를 해결해 주었지만 여전히 몇 가지 문제가 남아있다. 대표적으로 `Non-repeatable Read`라고 부르는 문제가 존재한다.

`Non-repeatable Read`는 **한 트랜잭션 내 값을 읽는 시점에 따라 같은 데이터의 값이 달라지는 문제**이다. 트랜잭션 초기 A라는 데이터를 읽은 후 마지막에 다시 읽는 그 사이에 다른 트랜잭션이 A의 값을 바꾸게 될 경우 발생할 수 있다. 

또 `Read Skew` 문제도 존재한다. 이 문제는 `Non-repeatable Read`에서 파생된 문제인데 **한 트랜잭션 사이에 다른 트랜잭션의 쓰기로 인해 데이터 정합성이 맞지 않는 문제**이다. 
Rokwon이 2개의 계좌에 따로따로 5원 씩 총 10원 저장해두었다. Rokwon이 모든 계좌에 저장된 돈을 가져와 보려고 할때, 동시에 계좌2 -> 계좌1로 1원의 송금이 발생한다고 가졍해보자. 타이밍이 좋지 않다면 아래 그림과 같이  Rokwon에게 최종적으로 보여지는 결과가 잘못될 수도 있다.

![Read Skew](https://github.com/kids-ground/mentos-backend/assets/52196792/f74d5a07-64e0-4953-a2e9-3b533843b7e2){: .align-center style="width: 70%;"}  
Read Skew
{: .image-caption style="font-size: 14px;" }  


스냅숏 격리는 이러한 문제를 해결하기 위한 격리수준이다. 각 트랜잭션이 데이터베이스의 일관된 스냅숏으로부터 데이터를 읽는 방법이다.

스냅숏 격리는 객체의 여러 버전을 유지하는 다중 버전 동시성 제어(MVCC, Multi-Version Concurrency Control)를 이용한다. 트랜잭션 시작시 고유의 id를 받고 해당 트랜잭션은 본인의 id보다 낮은 버전의 객체와 이미 커밋된 객체만을 읽는다. 

스냅숏 격리의 핵심은 **읽는 쪽에서는 쓰는 쪽을 차단하지 않고 쓰는 쪽에서도 읽는 쪽을 차단하지 않는다는 것**에 있다. 이렇게 잠금 경쟁없이 쓰기 작업이 처리되며 일관성 있는 읽기가 가능하다.


### 갱신 손실 문제
앞서 커밋 후 읽기와 스냅숏 격리 수준에서는 2개의 트랜잭션 중 하나는 읽기를 하나는 쓰기 작업으로 데이터에 동시 접근했을때의 문제에 대해 서술하였다.(Dirty Write 제외) 

그렇다면, 두 트랜잭션이 같은 데이터에 동시에 쓰기 작업을 실행한다면 어떻게 될까? 이럴 경우 갱**신 손실(lost update) 문제가 발생**할 수 있다. 갱신 손실 문제는 값을 읽고 변경 후 다시 값을 쓸 때(read-modify-write 주기라고 부름) 생기는 문제로 **이후 트랜잭션이 이전 트랜잭션의 쓰기를 무시하는 문제**이다.

아래 그림과 같이 두 트랜잭션이 같은 값을 읽은 후 쓰기를 진행하는 과정에서 나타날 수 있다. 마지막에 커밋하는 트랜잭션이 이전 트랜잭션의 결과를 무시해버리는 문제를 볼 수 있다.

![Lost Update](https://github.com/kids-ground/mentos-backend/assets/52196792/fab532cc-f7dd-4b00-8048-8ae3f92fffee){: .align-center style="width: 70%;"}  
갱신 손실
{: .image-caption style="font-size: 14px;" }  


위 문제를 해결하기 위해서 몇 가지 해결책들이 존재한다.

첫번째로 데이터베이스에서 지원해주는 **원자적 쓰기 연산을 사용하는 방법**이다. 읽고 쓰는 연산을 한 번의 질의로 끝낼 수 있다. 대부분의 데이터베이스에서 이 명령은 동시성 안전하다. 
```sql
UPDATE counters SET value = value + 1 WHERE key = 'v';
```

이 방법은 데이터베이스 내부적으로 보통 exclusive lock을 사용하여 구현된다. 모든 원자적 쓰기 연산을 단일 스레드에서 실행되도록 강제하는 방법이다.

두번째로 **명시적인 잠금**을 이용할 수도 있다. 읽고 쓰기 전까지 잠금을 직접적으로 거는 방식이다. 대표적으로 `SELECT FOR UPDATE` 구문이 있다.

세번째는 **갱신 손실을 자동을 감지**하여 갱신 손실이 발생하면 문제가 되는 트랜잭션을 어보트 시키는 방식이다. 아쉽게도 이 방식은 MySQL은 지원해주지 않는다.

네번째는 **Compare-and-set 방식**이다. **과거에 본인이 읽은 데이터와 같을 경우 업데이트 하는 방법**이다. DB가 WHERE 절 연산에서 오래전에 쓰여진 스냅숏으로부터 데이터를 읽게 된다면 이 방법은 갱신 손실을 막지 못할 수도 있다. 때문에 각 데이터베이스에 안전한지 확인하는 것이 필수다.
```sql
UPDATE name SET name = 'new name'
	WHERE id = 1 AND name = 'old name';
```

**💡 MySQL의 REPEATABLE READ 격리 수준은 Lost Update를 보장하지 못한다.**  
때문에 명시적인 Lock이나 다른 방법들을 사용해 문제를 해결해야한다.  
{: .notice--info}  


### 쓰기 스큐 문제
갱신 손실(Lost Update) 문제 외에도 쓰기 스큐(Write Skew) 문제가 발생할 수 있다. **쓰기 스큐는 같은 집합의 다른 두 객체를 동시 수정하여 집합에 대한 요구사항이 깨지는 문제**이다.

예시를 들어보자. 두 명 군인 Rokwon과 KIM은 함께 근무를 서고 있다. 누군가 한 명은 꼭 근무를 서야하기 때문에 동시에 휴가를 사용할 수는 없다. 이러한 상황에서 두 군인이 동시에 휴가를 신청한다고 가정해보자. 다음과 같은 상황이 발생할 수 있다. **서로 다른 객체를 수정함**으로 인해 더티 쓰기나 갱신손실이 일어나지는 않지만 전체 집합에서 원하는 결과가 맞춰지지 않는 문제이다.

![Write Skew](https://github.com/kids-ground/mentos-backend/assets/52196792/5c0badf6-bea9-4aa2-9d9a-a65126f1be05){: .align-center style="width: 70%;"}  
Write Skew
{: .image-caption style="font-size: 14px;" }  

비슷한 상황으로 `팬텀리드` 문제도 발생할 수 있다. A트랜잭션의 실행 도중 B트랜잭션이 A트랜잭션이 보고 있는 집합에 새로운 값을 추가하여 A트랜잭션이 이후의 집합과 관련된 질의에서 처음과 다른 정보를 받을 수 있다.


### 중간 정리
완화된 격리수준에서 일어날 수 있는 트랜잭션 이상현상에 대해서 정리해보자. 이상현상은 크게 두 가지 상황으로 나누어 볼 수 있다. 

한 트랜잭션에서는 읽기를 다른 트랜잭션에서는 쓰기 수행 시
- `Dirty Read` 
- `Non-Repeatable Read`
- `Read Skew`
- `Phantom Read` - 완화된 격리수준에서 처리하지 못함

두 트랜잭션이 동시에 쓰기 작업 수행 시
- `Dirty Write`
- `Lost Update`  - 완화된 격리수준만으로 처리하지 못하는 데이터베이스가 있음. 이 문제를 해결하기 위한 몇가지 방법이 존재한다.
	- 데이터베이스에서 제공해주는 원자적 쓰기 연산 사용
	- 명시적인 잠금
	- 몇 데이터베이스에서 제공하는 갱신 손실 자동 감지 기능
	- Compare-and-set 연산
- `Write Skew`  - 완화된 격리수준에서 처리하지 못함

