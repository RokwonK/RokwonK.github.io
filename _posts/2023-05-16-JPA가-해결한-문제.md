---
title: "객체지향으로 접근하는 데이터베이스 - JPA"
categories: Spring
tags:
  - JPA
---  


익히 알고 있듯 데이터베이스는 데이터를 생성하거나 조회를 하기 위해선 `insert`, `select` 와 같은 SQL 문법을 사용해야한다. 데이터베이스에 대해 공부해본 사람들이라면 익숙하게 사용할 수 있을 것이다. 하지만 이를 프로그래밍 언어를 기반으로 하는 서버 개발에서 사용하게 된다면 여러가지 문제에 맞닥뜨리게 된다.  

<br />  

### SQL을 이용한 개발의 문제점
1. **SQL을 직접 작성 & 결과값을 매핑**  
  - SQL 형식으로 코드를 작성하는 수고스러움, 받은 결과값을 일일이 객체로 매핑하는 작업을 직접 진행함에 따라 **개발 생산성이 떨어진다.**
2. **SQL에 의존적인 개발**  
  - SQL에 맞게 코드를 작성하다보면 이후 테이블 수정과 같은 상황이 발생했을때 대응하기 쉽지 않다. 이는 **명백히 유지보수성을 저하**시킨다.  
3. **연관객체 객체 조회**  
  - 테이블간의 연관관계를 쉽게 파악하기 힘들어 이를 확인하기 위해 많은 비용이 발생한다. 즉, **개발생산성 및 가독성의 문제**가 있다.  

<br />  

### JPA의 등장
SQL을 이용하여 직접 데이터베이스에 접근하고 결과값을 다시 프로그래밍 언어의 패러다임(객체지향)에 맞게 변환하는 방식은 개발 생상성은 물론 가독성, 유지보수성이 현저하게 떨어진다. 이러한 문제를 해결하기 위해 **객체의 관점으로 데이터베이스에 접근하는 방식으로 진화**하게 되었고 ORM(Object Relational Mapping)이 등장하게 되었다.

ORM이란 **객체지향 프로그래밍에서 관계형 데이터베이스와의 상호작용을 추상화**한 기술이다. 개발자는 데이터베이스 스키마를 직접 다루지 않고 데이터베이스 모델과 매핑된 객체 모델을 이용하여 생성, 수정, 삭제 연산을 진행한다. ORM 프레임워크는 이러한 연산을 자동으로 SQL를 쿼리로 바꾸어 데이터베이스와 상호작용을 하게된다. 덕분에 데이터베이스 모델을 직접 다루는데 필요한 코드들을 줄일 수 있었고, 객체지향 방식으로 코드의 일관성까지 갖출 수 있게 되었다. 정리하자면, **ORM은 데이터 접근 방식을 객체 방식의 접근으로 추상화하여 개발 생산성과 유지보수성을 높인 프레임워크**{: .font-highlight}인 것이다.

자바 진영에서의 ORM 기술 표준은 JPA(Java Persistence Api)이다. JPA는 표준 명세로 추상화된 인터페이스이다. 이를 통해 JPA 표준 명세를 구현한 여러 구현체들을 이용할 수 있다. Hibernate, EclipseLink, OpenJPA 등이 있으며 이 중 가장 많이 사용하는 것이 Hibernate이다.(Hibernate의 개발자가 JPA 표준 명세를 만들었다고 들었다)  
JPA는 내부적으로 JDBC API를 사용하여 데이터베이스와 상호작용을 맺는다. 즉, 객체관점으로 작성된 코드를 JPA를 구현한 프레임워크들이 JDBC API로 변환하여 동작한다는 뜻이다.  

<br />  

### 객체지향과 RDB 간의 불일치

객체지향과 관계형 데이터베이스는 세상에 나올때 부터 설게 중심이 달랐다. 때문에 객체지향에서의 관계(객체 중심 관계)와 데이터베이스의 관계(데이터 중심 관계)는 서로 다른 개념을 가진다. 이러한 문제는 ORM이 해결해야할 가장 큰 이슈이다. 어떤 문제가 있으며 JPA는 어떤 방식으로 해결하는지 알아보자.

1. 상속 문제
    1. 실제 데이터베이스에서는 상속개념은 결국 연관관계를 갖는 두 테이블로 나눠진다.
    2. 따라서, 자식 객체를 생성하거나 조회 시 두번의 insert 혹은 Join 연산을 진행해야한다.
    3. 객체지향에서는 관계를 만들어 놓는다면 컬렉션 내에 add, find 연산을 진행하면 된다. JPA에서도 컬렉션 연산으로 동작할 수 있도록 인터페이스를 설계하였고 내부적으로 insert, join 연산이 진행된다.
2. 객체간 연관관계, 연관 객체 탐색
    1. 데이터베이스에서 두 테이블의 연관관계는 외래키와 같은 데이터로 표시된다.
    2. 하지만 객체지향에서는 객체를 참조하는 방식으로 사용한다. 
    3. JPA에서는 이러한 참조방식을 지원해준다. 덕분에 객체간의 관계를 기반으로 연쇄적으로 연관된 객체들을 호출할 수도 있다.
    4. 지연로딩이라는 기술로 쿼리를 나누어 데이터들을 검색해준다.
        - 이로 인해 N+1 과 같은 문제점이 발생하기도 한다.
    5. 성능최적화까지 고민하여 설계해준다.
3. 객체 비교
    1. 데이터베이스로 같은 쿼리를 두번 날리면 동일한 결과값을 가져오지만 서로 다른 객체이다. 
    2. 하지만 자바 컬렉션에서 동일한 위치의 객체를 뽑아온다면 당연 같은 객체로 인식이 된다.
    3. JPA는 자바 컬렉션과 같이 동일한 트랜잭션 내에서 조회시 동일성을 보장해준다.
4. 추가적인 성능 최적화 기능 제공
    1. 1차 캐시를 지원하고 동일성을 보장해준다.
        - 같은 트랙잭션 내부에서만 가능
        - 약간의 조회 성능의 향상
        - DB의 isolation Level이 Read Commit이어도 어플리케이션 내에서 Repeatable Read 보장
    2. 트랜잭션을 지원하는 쓰기 지연
        - 트랜잭션 커밋 전까지 insert SQL을 모음(Buffer writing)
        - 커밋 시 JDBC BATCH SQL(직접 짜면 코드가 많아짐) 기능을 사용해서 한번에 SQL 전송
        - 네트워크 통신 시간 단축
        - UPDATE도 비슷한 매커니즘으로 시간을 단축할 수 있음
    3. 지연 로딩
        - 즉시 로딩 - 한 번에 연관된 객체까지 미리 조회
        - 지연 로딩 - 객체가 실제 사용될 때 로딩함(N+1 문제가 생길 수 있음)

<br />  

### JPA의 장점
- 생산성
- 유지보수성
- 추상화를 통한 외부 기술과의 낮은 결합성


<br />  

**아래 강의 및 도서를 학습 후 작성하였습니다.**  
- [인프런 - 자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic)
- [도서 - 자바 ORM 표준 JPA 프로그래밍](https://product.kyobobook.co.kr/detail/S000000935744)