---
title: "[운영체제] 효율적으로 물리 메모리 관리하기"
categories: CS
tags:
  - OS
  - 메모리
---  

컴퓨터 내부 장치들은 연산장치와 기억장치로 나누어진다. 연산장치에는 CPU와 GPU가 존재하며, 기억장치로는 RAM, SSD, HDD 등이 있다. 연산잔치는 일꾼으로 주어진 명령을 처리하는 역할을 할 뿐이며, 그 자체로 최대 처리 속도가 정해져있다.  

그렇다면, 컴퓨터의 속도는 오직 연산장치의 수준으로 결정되는가? 그렇지 않다. 연산장치는 기억장치에 저장되어 있는 프로그램들을 실행한다. 또한 기억장치에는 여러가지의 종류가 있고 계층 구조를 이루어 존재한다. 하나의 기억장치만 있다면 읽고 쓰는것만으로 충분하겠지만 계층을 이루는 구조에서는 데이터가 어디에 저장되어있는지에 따라 속도가 좌우된다. 그리고 **이러한 기억장치들을 컨트롤하는 것이 운영체제의 역할**이다.

<br />  

### 메모리 계층 구조
왜 하나의 기억장치를 사용하지 않고 계층 구조를 이룰까? CPU와 SSD(또는 HDD) 사이의 거리가 멀기 때문이다. CPU가 HDD에서 데이터를 가져오는 시간동안 CPU가 일을 처리하지 않고 기다리는 것은 낭비다. 따라서, CPU와 SSD 사이에 계층 구조를 둠으로써 처리 속도의 병목현상을 해소하고자 하였다. 일반적으로 메모리 계층 구조는 아래와 같다.  

> CPU Register -> Cache(SRAM) -> Main Memory(DRAM) -> SSD  

운영체제는 **이러한 메모리 계층 구조를 효율적으로 관리하는 역할**을 한다.

<br />  

### 주소 바인딩 - 논리주소와 물리주소 매핑
메모리 관리를 위해 메모리 주소는 물리주소와 논리주소로 나누어 관리한다. 물리주소는 말그대로 물리 메모리 자체의 주소이다. CPU는 여러가지 프로세스를 효율적으로 처리하기 위해 이 물리주소를 랩핑한 논리주소를 사용한다. **논리주소란, CPU가 생성하는 주소**이다. 각 프로세스들은 이 논리주소를 이용하여 메모리에 접근요청을한다. CPU는 이 논리주소를 MMU(Memory Management Unit)를 통해 실제 물리주소(또는 가상주소)로 변환하여 접근한다.  

왜 굳이 논리주소를 사용하는 걸까? 예상했듯이 **메모리를 안정적이고 효율적으로 관리**{: .font-highlight}하기 위해서이다. 논리주소를 통해 다음과 같은 문제를 해결할 수 있다.  

1. **프로세스의 독립성 보장**  
각 프로세스들은 가상주소를 통해서 본인들만의 독립적인 공간을 사용할 수 있다. 프로세스간 주소공간의 충돌을 최소화 할 수 있다.  
2. **메모리 보호**  
프로세스가 다른 프로세스의 주소 공간에 접근하려고 할때, 운영체제나 MMU가 보안 검사를 수행하여 불법적인 접근을 차단할 수 있다.  
3. **가상 메모리 사용가능**{: .font-highlight}  
가상 메모리는 논리주소를 사용하는 가장 핵심적인 이유이다. 만약 프로그램의 크기가 물리 메모리보다 크다면 어떡할까? 프로그램을 돌리기 위해서 물리 메모리 위로 올려야한다. 따라서, 프로그램의 더 크면 모든 메모리를 물리메모리에 올리지 못하는데 이때, 가상 메모리 기법을 이용한다. 실제로 모든 메모리를 물리 메모리에 올리지 않지만 모든 메모리가 올라와 있는 것처럼 속이고 프로세스를 운용할 수 있다.(가상 메모리에 관한 내용은 매우 중요한 내용이므로 다른 포스트에서 더 자세하게 알아보자)
4. **이식성**  
프로세스가 물리 메모리에 의존하지 않고 작업을 수행할 수 있다. 따라서 다른 시스템이나 환경으로 이식하는데 유리하다.

**💡 가상주소**  
가상 메모리(물리주소 또는 SSD에 존재)에 대한 논리 주소
{: .notice}  

