---
layout: default
parent: Archive
title: "MySQL의 구조와 Query 처리과정"
categories: Database
tags:
  - mysql
---  


## 설정

MySQL 서버는 단 하나의 설정 파일(`my.cnf`)을 사용한다. 이 파일 내에서 여러 개의 설정 그룹을 담을 수 있다. 

- 설정 파일 내에는 여러가지 시스템 변수 값들이 설정되어 있다.
- 시스템 변수는 **적용범위에 따라 글로벌 변수, 세션 변수**로 나누어진다. 
  - 일반적으로 세션별로 적용되는 시스템 변수는 글로벌, 세션에 동시에 존재한다.
- MySQL **서버 기동중에 상태를 변경할 수 있는지에 따라 정적, 동적 변수로 구분**된다.  
  - 동적변수의 경우 `SET` 명령어를 통해 시스템 변수값을 바꿀 수 있음. 하지만 `my.cnf` 에는 적용되지 않으므로 서버종료 시 초기화됨
  - MySQL 8.0 이상부터는 `SET PERSIST` 명령어를 사용하면 변경된 시스템변수는  별도의 파일(`mysqld-auto.cnf`)에 기록된다.

**💡 세션 변수**  
MySQL 클라이언트가 접속할때 기본으로 부여하는 옵션의 기본값을 제어하는데 사용  
대표적으로 자동 커밋모드로 시작하는 autocommit이 있음.
{: .notice--info}  

<br /><br />

## 사용자 및 권한
- Role(역할) - 권한 집합
- 사용자에게 Role 부여 가능

### 계정
1. 시스템 계정
  - 계정 관리 가능
  - 세션에서 실행중인 쿼리 강제 종료
2. 일반 계정
  - 
3. 내장 계정
  - `mysql.sys` - sys 스키마의 객체들의 DEFINER로 사용되는 계정
  - `mysql.session` - MYSQL 플러그인이 MySQL 서버로 접근할 때 사용되는 계정
  - `mysql.information_schema` - information_schema에 정의된 뷰의 DEFINER로 사용되는 계정  

<br /><br />  

## 아키텍쳐  
MySQL 서버는 **MySQL 엔진(머리)과 스토리지 엔진(손과 발)으로 구분**된다.  

### MySQL엔진 Overview
MySQL엔진은 클라이언트의 **SQL 쿼리 요청을 최적화**시켜 스토리지 엔진에게 쿼리처리 요청을 보내는 역할을 가진다.  

1. 커넥션 핸들러
  - 클라이언트로부터의 요청 처리
2. SQL 인터페이스, SQL 파서, SQL 옵티마이저, 쿼리실행기
  - 이 과정으로 최적화를 거쳐 실행계획을 세운다.
  - 실행계획에는 실제로 스토리지 엔진에 요청할 명령어들이 존재한다.
3. 캐시&버퍼

<br />  

### InnoDB 스토리지 엔진 Overview
MySQL 엔진으로부터 전달받은 쿼리를 이용해 **실제 데이터를 디스크에 저장하거나 디스크로부터 데이터를 읽어오는 역할**{: .font-highlight}을 담당한다.  

MySQL 엔진으로부터 전달받는 요청을 **핸들러 요청**이라 부르면 이러한 API를 핸들러 API라고 부른다.  

1. Transaction
2. Buffer pool & Undo log(In Memory)
  - Buffer pool은 가장 최신 데이터를 가지고 있으며 일종의 Cache 공간
    - 디스크로의 쓰기 지연이 되는 Buffer 공간의 기능도 있음
  - 커밋된 이후에 그 이전 데이터는 Undo log에서 가지고 있음.
    - 이 데이터에는 트랜잭션ID도 가지고 있음
    - MVCC를 구현한 것?(잠금 없는 일관된 읽기 기능 등)
3. Clustering Index
4. MVCC
5. Deadlock detect
6. Foreign key 


**Undo와 Redo**  
Undo는 되돌리기(롤백), Redo는 복구의 용도이다. Undo는 트랜잭션 내 일관성을 보호하고 격리수준을 보장하기 위함이라면 Redo는 장애와 같은 문제로 인한 데이터 유실을 보호하기 위해 사용한다.
{: .notice--info}  


<br />

### 쓰레드 구조  
MySQL 서버는 멀티 스레드 기반으로 작동한다.
1. 포그라운드 스레드
  - 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재
  - 커넥션이 종료되면 해당 스레드는 스레드 캐시로 돌아간다.
  - **클라이언트가 요청한 쿼리문장을 처리**
    - 데이터를 InnoDB의 버퍼나 캐시로부터 가져옴
    - 없는 경우 백그라운드 스레드가 디스크나 인덱스 파일에서 불러옴
    - MyISAM은 위 과정을 모두 포그라운드 스레드에서 처리함
2. 백그라운드 스레드
  - 로그 기록 스레드(디스크에)
  - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  - 데이터를 버퍼로 읽어 오는 스레드
  - Lock, DeadLock을 모니터링하는 스레드
  - Inser Buffer를 병합하는 스레드

<br />  

### 메모리 구조  
메모리 구조는 글로벌과 세션 메모리 구조로 나누어 진다.

1. 글로벌 메모리 영역
  - 스레드 수와 무관하게 **하나의 메모리 공간만 할당**되고 모든 쓰레드가 공유한다.
2. 세션 메모리 영역
  - 쿼리를 처리하는데 사용하는 메모리 영역
  - 스레드별로 독립적으로 할당되며 절대 공유하지 않는다.  

<br />  

### 플러그인 아키텍쳐 & 컴포넌트 아키텍쳐
스토리지 엔진을 바꿔낄 수 있음 스토리지 엔진은 단순히 데이터 읽기/쓰기 작업만 하지만 어떤 스토리지를 사용하느냐에 따라 특정 작업을 빠르게 처리할 수 있을 것이다.  

MySQL 8.0 부터는 컴포넌트 아키텍쳐가 도입되었다. 컴포넌트 아키텍쳐는 기존 플러그인 아키텍쳐의 단점들을 보완하였다.
- 플러그인은 MySQL 서버와 인터페이스할 수 있지만 플러그인끼리는 통신불가
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하여 안전하지 않음
- 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움  

<br />  

### 쿼리 실행 구조
Client로부터 SQL요청이 들어오면 MySQL 엔진에서는 쿼리를 최적화 시킨 이후 스토리지 엔진으로 실행 명령을 보낸다. MySQL 엔진에서의 실행과정을 알아보자.

1. 쿼리파서
  - SQL 문장을 토큰으로 나누어 트리형태(파스트리)로 만들어준다.
  - SQL 구문에서 예약어가 존재하는지 등의 문법 오류를 확인한다.
2. 전처리기
  - 파스트리에서 예약어를 제외한 토큰을 검사
  - DB에 해당 객체가 존재하는지, 권한을 검증
  - 이제 검증 완료!
3. 옵티마이저
  - 파스트리를 실행계획으로 바꾸는 역할
  - 쿼리를 재작성하고 테이블 스캔 순서 결정, 사용할 인텍스를 선택(최적의 쿼리를 실행하기 위함)
  - 비용기반 최적화와 규칙기반 최적화로 나누어짐
    - 비용기반 - mySQL의 통계정보를 활용함(대부분 이걸로 사용함)
    - 규칙기반 - 직접 규칙을 만듬. 같은 쿼리는 같은 실행계획을 만듬
4. 쿼리실행기(실행 엔진)
  - 실행계획을 토대로 핸들러 API를 이용하여 스토리지 엔진과 통신

<br />  

### InnoDB의 스토리지 엔진의 특징
1. 인덱스(프라이머리, 세컨드)
  - 프라이머리 인덱스(클러스터링 인덱스 - 데이터가 존재함)
  - 세컨더리 인덱스(데이터가 프라이머리 키 값임)
2. 외래 키 지원
3. MVCC(Multi Version Concurrency Control)
  - 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
  - 목표는 잠금을 사용하지 않는 일관된 읽기를 제공하는 것(언두 로그를 이용!)
  - 언두 영역의 데이터는 커밋을 한다고 바로 삭제되지는 않음 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제됨
4. 잠금 없는 일관된 읽기
  - MVCC와 마찬가지로 언두로그를 통해 이를 충족
5. 자동 데드락 감지
  - 교착 상태를 감시하기 위해 잠금대기 목록을 그래프 형태로 관리한다.
6. 자동화된 장애 복구
7. 버퍼 풀
  - InnoDB의 가장 핵심적인 부분. 데이터나 인덱스 정보를 메모리에 **캐시해 두는 공간**
  - **쓰기 작업을 지연**시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 한다.
  - 페이지 크기(시스템 변수)의 조각으로 쪼개어 관리한다.
  - 쓰기 버퍼링 기능을 향상을 위해선 리두 로그와의 조작이 필요(플러시 기능 등 알기)
8. Double Write Buffer
  - 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록되는 이때 일부 내용이 기록되지 않는 현상이 일어난다. 이를 해결해 주는 역할을 한다.
9. 언두 로그
  - 변경전 백업된 데이터
10. 체인지 버퍼
  - 데이터 추가 시 인덱스를 업데이트해야하는 경우, 변경해야 할 인덱스 페이지가 디스크에 존재한다면 즉시 실행하지 않고 체인지 버퍼라는 임시공간에 저장한다. 
11. 리두 로그 및 로그 버퍼
12. 어댑티브 해시 인덱스
  - InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
  - B Tree의 검색 시간을 줄여주기 위해 도입된 기능. 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만드는 것
  - B Tree의 리프 노드까지 찾아가는 비용이 없어짐  

<br /><br />  

## 트랜잭션과 잠금
**락은 동시성 제어를 위한 것(동시에 같은 데이터를 수정, 변경 방지)**이고 **트랜잭션 격리 수준은 일관성의 정도(변경 중 읽기)를 위한 것**이다.  

트랜잭션 코드는 최소화하기
1. 트랜잭션 내부에서 외부 API와 같이 네트워크 통신하는 것은 지양하자
  - 해당 API가 오랜시간이 걸린다면 그만큼 트랜잭션이 유지되는 것
2. 성격이 다른 트랜잭션은 별도의 트랜잭션으로 나누어 사용하자.  

<br />  

### MySQL 엔진의 잠금
1. 글로벌 락
  - MySQL에서 제공하는 잠금 가운데 **가장 범위가 큼**
  - select를 제외한 대부분의 DDL, DML이 대기 상태
  - 8.0 부터는 조금은 완화된 백업 락 이란 것도 생겼다.
2. 테이블 락 (테이블 데이터 동기화)
  - 개별 테이블 별로 설정되는 락.
  - 명시적, 묵시적으로 획득할 수 있다.
  - MyISAM이나 MEMORY 테이블의 데이터를 변경(DDL, DML)할때 발생
  - InnoDB에서는 스키마 변경(DDL)의 경우에만 테이블 락이 발생
3. 네임드 락 (사용자의 필요에 맞게 사용할 수 있음)
  - 테이블이나 레코드가 아닌 사용자가 지정한 문자열에 대한 락
  - 자주 사용되지 않음
4. 메타데이터 락 (테이블 구조 락)
  - 테이블의 이름이나 구조를 변경하는 경우의 락
  - 새로운 테이블을 만들고 해당 테이블로 이전 테이블의 데이터를 옮길때 사용  

<br />  

### InnoDB 스토리지 엔진의 잠금  
1. 레코드 락
  - 다른 DBMS와 같이 레코드 자체가 아니라 InnoDB는 **인덱스의 레코드를 잠금**
  - 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 **클러스터 인덱스를 이용해 잠금을 설정**한다.  
2. 갭락
  - 레코드와 인전합 레코드 사이의 간격만 잠그는 것?
3. 넥스트 키 락
4. 자동 증가 락
  - auto increment와 관련된 락
  - 명시적으로 획득하고 해제하는 방법은 없음  

InnoDB의 레코드락은 인덱스의 레코드를 잠근다는 말을 이해하고 넘어가자.  
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드들에 모두 락
- 즉, 찾고자하는 값이 존재하는 인덱스의 리프노드에 존재하는 레코드들의 실제 레코드들이 전부 락이 걸린다.
- 만약 찾는 테이블에 인덱스가 하나도 없다면? 
  - 테이블 풀 스캔이 일어나고 해당 테이블의 모든 레코드들이 잠기게 된다.
- 때문에, InnoDB에서의 인덱스 설계가 매우 중요하다.  

<br />  

### MySQL의 격리수준
**여러 트랜잭션이 동시에 처리될때, 트랜잭션이 다른 트랜잭션에서 변경/조회 중인 데이터를 볼 수 있게 허용할 것인지를 결정하는 것**{: .font-highlight}이 트랜잭션 격리수준이다.  

1. READ UNCOMMITED
  - commit되지 않았더라도 최신 데이터를 읽음
2. READ COMMITED
  - commit 되지 않은 데이터라면 변경되기 전의 데이터를 읽음
  - Non-Repeatable Read 문제 발생
    - A 트랜잭션 진행 중 B 트랜잭션이 read 중인 data를 수정하고 commit
    - A 트랜잭션이 읽는 시점에 따라 쿼리가 같아도 다른 데이터를 받음
3. REPEATABLE READ
  - 백업과 트랜잭션 버전을 이용하여 현재 트랜잭션 버전에서의 데이터를 읽음
  - transactionId를 이용해 undo도 포함하여 현재 transaction에서 사용되던 정보만 읽음
  - Non-Repeatable Read는 해결
  - **해당 트랜잭션을 실행하는 순간에 이미 존재하는 데이터가 아니라, 새로운 레코드가 추가되는 것을 막지 못함.** - Phantom read 발생
4. SERIALIZABLE
  - InnoDB의 갭락과 넥스트 키 락 덕분에 REPEATABLE READ 수준에서 Phantom read가 발생하지 않는다고 한다.
  - 때문에 굳이 사용할 필요가 없다고 한다.  

<br /><br />  

## 데이터 압축

**파일이 클수록 백업, 복구에 드는 시간도 크다. 뿐만 아니라 한정된 저장공간을 낭비하게 될 수도 있다.** 이러한 문제를 해결하기 위해 데이터 압축을 사용한다.  

MySQL이 사용하는 압축방식은 크게 테이블 압축과 페이지 압축이 존재한다.  

<br /><br />  

## 데이터 암호화

MySQL 8.0부터는 리두 로그, 언두 로그, 복제를 위한 바이너리 로그 등 모두 암호화할 수 있는 기능을 제공한다. 데이터 암호화는 보안 감사에서 필수적으로 언급된다.  

핀테크와 같이 중요한 정보를 저장하는 서비스에서는 1. 응용 프로그램에서 암호화, 2. 데이터베이스 서버에서 암호화를 하여 이중 암호화하는 방법을 선택한다.  

1. 데이터 암호화
2. keyring_file 플러그인 설치
3. 테이블 암호화
4. 언두 로그 및 리두 로그 암호화
5. 바이너리 로그 암호화  

<br /><br />  

## 인덱스

데이터베이스의 성능 튜닝은 **어떻게 디스크 I/O를 줄이느냐**{: .font-highlight}가 관건일 때가 상당히 많다.  

일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것(쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개션하는 것)이 목적
- 인덱스 레인지 스캔 - 주로 랜덤 I/O 사용
- 풀 테이블 스캔 - 순차 I/O  

![InnoDB 인덱스 구조](https://github.com/kids-ground/shout-backend/assets/52196792/7ed7b3a7-2395-46e9-b646-cb3b05630844)  

### B-Tree 인덱스 키 CRUD
1. 추가
  - 유니크 인덱스는 중복체크가 필요하므로 즉시 추가
  - 세컨더리 인덱스는 지연 추가
2. 삭제
  - 해당 키 값의 리프노드를 찾아가 삭제 마크만 하면 완료
3. 변경
  - 위에 설명한 삭제 이후 추가
4. 검색


### 인덱스 선택하기
Cardinality(기수성)가 높은 컬럼을 인덱스로 선정하는게 좋음(중복도가 낮은 컬럼)

### 읽어야하는 레코드의 건수에 따른 인덱스의 성능
보통 전체 레코드의 20~25%가 넘으면 인덱스가 아닌 테이블 데이터를 직접 읽고 필요한 부분만 필터링하는게 더 빠른 방법이다.

### 인덱스 스캔 방식
1. 인덱스 레인지 스캔 - 데이터를 한 건 이상 읽기
  - 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
2. 인덱스 풀 스캔 - 인덱스의 처음부터 끝까지 모두 읽는 방식
  - 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬림이 아닌 경우 사용됨
  - Index(A,B,C)인데 B,C로 검색한 경우
  - **테이블 전체를 읽는 것보다는 적은 디스크 I/O로 쿼리를 처리**할 수 있음
3. 루스 인덱스 스캔
4. 인덱스 스킵 스캔
  - MySQL 8.0부터 옵티마이저가 Index로 설정한 첫 컬럼을 건너띄고 두번째 컬럼으로만으로도 검색이 가능하게 해주는 최적화 기능을 도입하였다.

<br /><br />  

## 옵티마이저와 힌트


<br /><br />  

## 실행 계획