---
layout: default
parent: Archive
title: "데이터베이스 인덱스"
categories: Database
tags:
  - mysql
---  


MySQL의 InnoDB 스토리지 엔진은 B+트리를 기본적으로 지원한다.

인덱스는 데이터베이스 테이블에 대한 검색 성능을 향상시키는 자료 구조로 Where 절 등을 통해 활용된다.
**인덱스가 적용된 대상을 Where절을 통해 검색한다.(Where 절을 사용하지 않으면 인덱스가 걸리지 않음)**  

**특징**  
- 항상 최신의 정렬상태를 유지한다
- 하나의 데이터베이스 객체이다.
- 데이터베이스 전체크기의 약 10% 정도의 저장공간을 필요로 한다.

**인덱스 알고리즘**  
페이지 - 데이터가 저장되는 단위(보통 16kbyte)
- Full Table Scan  
  - 순차적으로 다 찾음, 접근비용이 감소
  - 적용 가능한 인덱스가 없는 경우, 인덱스 처리 범위가 넓은 경우, 크기가 작은 테이블에 액세스하는 경우 데이터베이스가 판단하여 사용될 수 있다.
- B+-Tree와 B-Tree
  - 자식 노드를 2개이상 가질수 있음(기본 데이터베이스 구조)
  - 리프 페이지에 데이터를 저장, 루트/브랜치 페이지는 자식 페이지의 정보를 가짐
  - Insert시 페이지에 새로운 데이터를 추가할 여유공간이 없어 페이지 분할이 발생 -> 상위 페이지까지 구조가 바뀌어 성능이 느려짐
  - Delete시 실제로 데이터를 지우지않고 사용안함 표시를 함
  - Update시에는 Delete 매커니즘 이후 Insert 매커니즘을 사용

**놀라운 사실**  
- 자동으로 인덱스가 생성된다!
- unique, primary key 제약조건은 인덱스를 생성해준다.
  - primary key - 클러스터링 인덱스 자동생성
  - unique - 논-클러스터링 인덱스 자동생성


**인덱스 종류**  
- 클러스터링 인덱스
  - 실제 데이터와 무리를 이룸
  - 클러스터링 인덱스 적용하는 방법
    1. primary key 적용(우선순위가 더 높음)
    2. not null과 unique 동시에 걸기
  - 인덱스 구성 후
    1. 적용한 컬럼을 기준으로 데이터 정렬(리프 페이지에 모든 데이터를 다 가지고 있음)
    2. 정렬된 데이터를 기준으로 루트페이지가 생성됨
  - 실제 데이터 자체가 정렬되어 있음
  - 테이블당 1개만 존재 가능
  - 리프 페이지가 데이터 페이지(모든 정보를 가지고 있음)
- 논-클러스터링 인덱스(보조, 세컨더리 인덱스)
  - 실제 데이터와 무리를 이루지 않음(별도의 인덱스 - 책 뒤에 별도로 존재하는 찾아보기 페이지 같은 것)
  - 적용 방법
    1. unique 제약조건
    2. 직접 생성 - create unique index(중복 허용 X)
    3. 직접 생성 - create index(중복 허용 O)
  - 실제 데이터가 저장된 데이터 페이지는 정렬 등의 변경이 이뤄지지 않음
  - 리프 페이지에는 별도의 인덱스 페이지(추가적인 공간이 생긴다는 것)가 들어감
  - 리프 페이지에는 논 클러스터링 인덱스를 걸어놓은 컬럼과 실제 데이터가 존재하는 데이터 페이지와 요소의 위치(실제 데이터 페이지 주소)를 가지고 있는다.
- 둘 다 적용한다면?
  - 논-클러스터링 인덱스의 리프 페이지에는 실제 데이터 페이지의 주소가 아닌 클러스터링 인덱스를 건 컬림이 존재한다. 따라서, 논-클러스터링 인덱스로 검색시 검색결과로 클러스터링 인덱스로 다시 검색한다. - 주소를 가지고 바로 접근하지 않는 이유는 주소가 변결될 수 있기 때문이다.(페이지 분할)

**인덱스 적용 기준**  
1. 카디널리티 - 그룹 내 요소의 개수
  - 카디널리티가 높은(중복수치가 낮은) 것에 적용해야한다!
  - 중복도가 높으면 인덱스 효과가 적다
2. Where, Join, Order By 절에 자주 사용되는 컬럼
3. Insert, Update, Delete가 자주 발생되지 않는 컬럼
4. 규모가 작지 않은 테이블

**추가**
- SQL 최적화
- 다중 컬럼 인덱스
- ANALYZE TABLE
- B+Tree



**참고**  
- https://mangkyu.tistory.com/286
- https://tech.kakao.com/2018/06/19/mysql-ascending-index-vs-descending-index/
- https://zorba91.tistory.com/293