---
layout: default
parent: Archive
title: "[네트워크] 전송계층 TCP와 UDP"
categories: CS
tags:
  - network
---  

전송계층은 네트워크에서 **데이터를 안정적으로 전송하기 위한** 계층으로 **신뢰성 있는 데이터 전송을 보장**하는 역할을 한다. 전송계층의 아래계층들은 목적지 컴퓨터까지 전송을 해주는 역할을 하지만 목적지 도착 이후에 데이터의 확인을 하지는 않는다. 전송계층은 양 끝단에서 수문장의 역할로서 데이터의 제어를 담당한다.  

전송 계층의 특징은 프로토콜에 따라 2가지로 구분할 수 있다.  
- **신뢰성/정확성** : 데이터를 목적지에 `문제없이` 송수신(연결형)
- **효율성** : 데이터를 목적지에 `빠르게` 송수신(비연결형)  

데이터의 신뢰성과 정확성을 보장하는 프로토콜은 TCP이며 효율적인 통신을 위한 프로토콜은 UDP가 있다.  

<br />  

## TCP
TCP(Transmission Control Protocol)는 전송계층 프로토콜로 신뢰성과 정확성을 보장하는 프로토콜이다. 이를 위해 TCP에서는 **1대1 연결을 수립** 후 통신을 시작하며 **패킷의 순서확인** 및 **흐름,혼잡,에러제어 방식을 사용**한다.  


### TCP 헤더
TCP의 헤더에는 출발지와 목적지의 정보 및 신뢰성을 보장하기 위한 여러가지 영역을 가지고 있다.

![tcp_header](https://user-images.githubusercontent.com/52196792/226360175-16f3675f-292c-46df-99a7-33f8dae91a76.png){: .align-center style="width: 60%;"}  
TCP 헤더구조
{: .image-caption style="font-size: 14px;"}  

- **포트번호**
  - 각 송수신지의 포트번호
- **일련번호**  
  - 송신지에서 수신측에 몇 번째 데이터인지 알려주는 역할  
  - 패킷의 순서확인 및 재전송에 사용
- **확인 응답 번호**  
  - 수신측에서 몇 번째 데이터를 수신했는지 알려주는 역할  
  - 패킷 재전송에 사용
- **코드 비트**
  - TCP 헤더의 연결 제어 정보가 존재
  - TCP 연결/해제에 사용되는 필요 비트들이 존재
- **윈도우 크기**  
  - 버퍼 용량의 크기로 흐름제어에 사용  

<br />  

### TCP 연결 수립과 해제 - handshake
TCP는 데이터 전송 전 송수신지가 연결을 통해 **가상의 독점 통신로**를 만든다. 이때 연결 수립시 3-way-handshake가 일어나고 통신 종료 후 연결 해제시 4-way-handshake가 일어난다.  

**3-way-handshake**{: .font-highlight}  
안정적인 연결을 설정하기 위해 사용한다. 이때 TCP 헤더의 코드비트 중 `SYN`과 `ACK`을 이용하여 연결을 설정한다.
1. **Client -> Server**  
  - 연결 요청을 의미하는 `SYN` 코드비트
  - Sequence Number(일련 번호)에 난수를 지정
  - Server로 전송
2. **Server -> Client**  
  - 요청에 응답이라는 의미로 `ACK` 코드비트
  - Ack Number(확인응답번호)에 받은 Sequence Number + 1 담음
  - 포트를 열어달라는 요청의 의미로 `SYN` 코드비트
  - Sequence Number에 서버측의 난수를 지정
  - Client로 전송
3. **Client -> Server**
  - 서버에 응답으로 `ACK`을 담아 보낸다.
  - Ack Number(확인응답번호)에 받은 Sequence Number + 1 담음
  - 이후 연결이 수립되고 실제 데이터를 주고받는다.  
<br />  

**4-way-handshake**{: .font-highlight}  
데이터를 전부 주고받은 후 TCP 연결을 해제한다. 이때 `FIN`, `ACK`와 time-wait 정책을 이용한다.
1. **Client -> Server**
  - 연결 종료라는 의미의 `FIN` 코드비트 Server로 전송
2. **Server -> Client**
  - 요청에 대한 응답으로 `ACK` 코드비트 Client로 전송
3. **Server -> Client**
  - 서버측에서 남은 데이터 처리가 끝난 후 Client에 연결 종료 요청
  - `FIN` 코드비트 Client로 전송
4. **Client -> Server(and time-wait)**
  - 요청에 대한 응답으로 `ACK` 코드비트 Server로 전송
  - 이때 바로 연결을 종료하지 않고 일정 기간 기다림(Time wait)  

**💡 연결과 해제에서 단계가 차이나는 이유**  
요청을 먼저 받는 쪽에서 **처리할 데이터가 남아 있을 수 있기 때문**이다. 따라서 연결 수립 시에는 응답과 요청을 함께 보냈지만 연결 해제시에는 응답을 먼저 보내고 데이터를 전부 처리한 후 해제 요청을 보낸다. 즉, ACK와 FIN 따로따로 나누어 보내기 때문에 단계가 차이난다.  
{: .notice--info}  

**💡 Time-wait 정책**  
네트워크 혼잡 등의 문제로 ACK응답이 상대측에 도달하지 않을 수 있다. 따라서 재요청을 대비해 바로 연결을 해지하지 않고 일정기간 기다리게 된다.
{: .notice--info}  

**💡 Sequence Number에 난수를 담는 이유**  
난수가 아닌 순차적은 Number로 전송하면 이전 연결에서 사용한 패킷으로 인식할 수 있기 때문에 이러한 가능성을 줄이기 위해 난수를 설정한다.
{: .notice--info}  

<br />  

### 데이터 확인
TCP는 **받은 데이터가 기대하던 데이터**인지 확인 할 의무가 있다. 따라서 패킷에 순서를 지정하고 해당 패킷을 받았다며 응답을 보낸다. `Sequence Number(일련변호)`를 이용해 해당 해킷의 순서를 알려주며 `ACK Number(확인응답번호)`를 이용해 해당 패킷을 무사히 잘 받았다고 응답한다. 이러한 상호작용으로 정확성 높은 데이터 통신을 구축할 수 있다.  

<br />  

### 원활한 통신을 위한 패킷제어  
TCP는 원활한 통신을 위해 몇가지 제어방식을 사용한다. TCP에서의 이러한 기능들 덕분에 개발자는 패킷문제에 대해서 일일이 신경쓰지 않고 상위 레이어(응용계층)의 동작에만 집중할 수 있다. 
- **`흐름제어`** : 한 번에 전송할 데이터 양을 조절
- **`혼잡제어`** : 네트워크의 혼잡에 대처하여 데이터 양 조절
- **`오류제어`** : 통신 도중 유실되거나 잘못 수신된 데이터 제어  

(각 제어방식마다 여러가지 메커니즘이 존재한다. 이에 대해서는 따로 포스팅하도록 하겠다)  

<br />  

## UDP
UDP(User Datagram Protocol)는 **빠른 속도와 효율성을 중요시한 프로토콜**이다. UDP는 TCP와 달리 연결과정이 없으며 상대방과 응답을 확인하지 않고 연속해서 데이터를 보낸다. 따라서 데이터 전송을 보장하지 않고 순서대로 전송되는 것도 보장하지 않는다. 하지만 **통신에 대한 오버헤드가 적어 보다 빠른전송이 가능**하다. ex) 실시간 응용 프로그램, 영상 및 음성 스트리밍 등 

### UDP의 헤더  
UDP의 헤더는 간단하게 이루어져 있다. TCP와 같이 여러가지 제어 및 신뢰성/정확성에 필요한 헤더들이 빠져 보다 가벼운 헤더로 구성되어 있다.  
1. 출발지, 목적지 포트번호(각 16비트)
2. 길이(16비트)
3. 체크섬(16비트)  

<br />  

### 브로드캐스트 지원  
브로드캐스트는 네트워크의 모든 호스트에게 패킷을 전송하는 것이다. 브로드캐스트는 주로 네트워크 상의 모든 호스트에게 **특정 정보를 전파하기 위해 사용**된다. 즉, 1:N의 상황에서 유용하게 사용할 수 있다.  