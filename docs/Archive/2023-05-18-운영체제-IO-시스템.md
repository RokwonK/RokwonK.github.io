---
layout: default
parent: Archive
title: "[운영체제] 디스크 IO 시스템"
categories: CS
tags:
  - OS
  - I/O
---  

주변장치, 입출력장치라고도 부르며 입력장치, 출력장치, 보조기억장치 등이 속한다. 주변장치에는 키보드, 마우스, 프린터, USB, 하드디스크, 그래픽카드 등이 존재한다. 

컴퓨터에서 데이터 처리는 CPU의 역할이다. 주변장치 또한 CPU에 처리요청을 보내지만 직접적으로 바로 요청을 보내지 않고 I/O Controller를 통해 이루어진다.  

<br />  

## 디스크와 통신하기

### I/O Controller
CPU와 주변장치 사이에 존재. I/O Controller를 이용함으로써 얻을 수 있는 이점은 다음과 같다.  
1. 데이터 버퍼링
  - 주변장치는 CPU보다 속도가 느림
  - 때문에 데이터를 버퍼에 저장하고 한 번에 처리 요청
  - 그 동안 CPU가 다른 작업을 처리할 수 있어 효율성이 좋아짐
2. 제어 및 동기화
  - 주변장치의 동작을 제어
  - CPU와 사이에서 동기화를 유지하고 데이터의 일관성, 무결성을 보장
3. 성능 향상
  - I/O Method를 이용하여 입출력 작업을 최적화 해줌
  - 데이터 전송 속도를 개선하고 CPU의 부하를 줄여줌  


<br />  

### I/O Method
I/O Controller를 통한 CPU와 주변장치간의 데이터 처리방법  
CPU의 사용률을 최대로 높이면서 정확한 주변장치 데이터 처리를 목표

1. Polling I/O  
  - 입출력 장치에 대한 처리
  - 문자(byte) 단위 데이터 처리
  - CPU가 I/O Controller에 요청한 후에 주기적으로 확인
  - CPU가 Synchronous 처리를 하며 CPU 효율성이 낮음
2. **Interrupt driven I/O**  
  - 입출력 장치에 대한 처리
  - 문자(byte) 단위 데이터 처리
  - 데이터 완료시 CPU에 interrupt 보냄
  - CPU가 Asynchronous 처리를 하며 CPU 효율성이 높음
  - 하지만 문자당 interrupt가 발생함
3. **DMA(Direct Memory Access)**  
  - **저장장치(HDD, SDD)**에 대한 블록 단위 데이터 처리
  - CPU가 요청시 데이터주소와 크기를 알려줌 -> CPU간섭없이 메모리 직접접근하여 요청받은 데이터 처리 -> 완료 후 CPU interruptㄴ
  - 블록 당 interrupt 발생
  
<br />  
<br />  

## 디스크 관리하기

### 디스크를 논리적으로 분할하기
대용량 저장장치를 파티션이라고 불리는 논리적인 공간단위로 분할한다. 각 파티션마다 하나의 파일 시스템을 탑재한다.
- window는 각 저장장치, 파티션에 알파벳순으로 드라이브 이름을 부여함(C 드라이브)
- linux는 저장장치를 파일로 취급함
  - 파티션으로 나누는것 = 새로운 디렉터리가 생성되는 것
  - 해당 파티션에 파일시스템을 설치하고 실제 디렉토리에 마운트함  

<br />  

### 디스크 포맷하기
포맷이란 디스크에 파일 시스템을 설치하고 디스크의 모든 섹터 내의 데이터를 지우는 것.  

- 빠른 포맷 - 파일 테이블만 초기화(모든 섹테 내 데이터를 지우지 않음)
- 느린 포맷 - 파일 테이블 초기화 및 섹터 내의 모든 데이터를 지움  

**💡 파일 시스템**  
파일 관리를 용이하도록 하기 위한 트리구조의 시스템. 파일 테이블을 가지고 각 테이블요소가 실제 파일을 참조함. window는 FAT, NTFS 등의 고유 파일 테이블이 있으며, linux는 파일테이블이 파일의 inode(파일의 정보가 담긴 구조체)를 참조함
{: .notice--info}  


**💡 하드디스크 구성요소**  
- 헤드 - 데이터를 읽고 쓰는 역할을 수행하는 부품(I/O Controller에 의해 제어)
- 트랙 - 디스크 표현에 그려진 경로로 여러 섹터를 가짐, 고유한 식별자를 가짐
- 섹터 - 트랙 내에 존재하며 데이터를 저장하는 최소 단위  
{: .notice}  

파일 시스템에서의 1개의 블록 = 여러개의 섹터

<br />  

### 디스크 스케줄링  
헤드가 디스크에 접근해서 데이터를 읽어 메모리에 걸리는 시간이 존재한다.  
- 탐색시간 - 헤드가 트랙까지 이동하는 시간
- 회전 지연시간 - 헤드가 섹터까지 이동하는 시간
- 전송시간 - 데이터를 읽어 메모리에 전손하는데 걸리는 시간

이중 탐색시간을 줄이기 위해 헤드의 트랙 이동을 최소화하기 위한 여러가지 알고리즘이 존재한다.

1. FCFS
  - 입출력 요청을 받는 순서대로
2. SSTF
  - 가장 가까운 트랙으로 이동
  - FCFS보다 빠름
  - 멀리 있는 트랙은 처리률이 낮아져 아사현상 발생
3. SCAN
  - 양 끝 트랙을 왔다갔다함(한쪽 끝 트랙에 도착하면 반대쪽으로 이동)
  - FCFS보다 좋은 성능
  - 동일한 트랙에 대한 요청이 계속들어오면 바깥쪽 트랙에 아사 현상이 발생가능
  - 중간에 있는 트랙 두번 접근
4. C-SCAN
  - 중간 트랙을 건너띄고 바로 반대 트랙으로 이동
  - SCAN과 같은 문제발생
5. Look
  - 양끝까지 가지 않고 입출력 요청을 받은 트랙까지만 접근(헤드의 트랙 이동을 줄임)
  - 중간에 있는 트랙 두번 접근
6. C-Look
  - Look과 C-SCAN의 혼합형 - 한 반향으로 이동하면서 입출력 요청 받은 헤드에 접근